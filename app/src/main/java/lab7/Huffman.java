/*
 * This source file was generated by the Gradle 'init' task
 */
package lab7;
import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;
import heap.Heap;
import avl.AVL;
import java.util.HashMap; 
import java.util.ArrayList;
import java.util.Map;

public class Huffman {

    public static class Node{
        public String key;
        public Integer freq;
        public Node left;
        public Node right;
        public Node parent;
        public StringBuilder path;

        public Node(String s, Integer v){
            key = s;
            freq = v;
        }
        public Node(Node left, Node right){
            this.freq = left.freq + right.freq;
            this.left = left;
            this.right = right;
            this.left.parent = this;
            this.right.parent = this;
            this.path = new StringBuilder();
        }
    }

    public static void main(String[] args) {
        Node tree = createTree(args[0]); //Create the Huffman coding tree from the input file
        Map<String, String> bitMap = null;  //Start with an empty map for frequencies
        StringBuilder inputString = getInput(args[0]);  //Get original input for comparison
        StringBuilder encodedString = encode(args[0], tree, bitMap); //Encode (turn letters into numbers)
        StringBuilder decodedString = decode(tree, tree, new StringBuilder(encodedString), new StringBuilder()); //Turn numbers into letters
        //printTree(tree);   // Uncomment to print the Huffman tree structure(hard to read with large files)
        if(decodedString.length() < 100){  // Print only if the decoded string is short enough
            System.out.println(inputString);
            System.out.println(encodedString);
            System.out.println(decodedString);
        }
        // Always print these 
        System.out.println("Decoded equals input: " + inputString.equals(decodedString));
        System.out.println("Compression Ratio: " + encodedString.length() / (inputString.length() / 8.0));
    }
    
    //Turns input file into a StringBuilder to look at and compare with
    public static StringBuilder getInput(String fileName){
        StringBuilder retString = new StringBuilder();
        Scanner sc;
        File input = new File(fileName);
        try{
            sc = new Scanner(input);
        } catch (FileNotFoundException e){
            e.printStackTrace();
            return null;
        }

        while(sc.hasNextLine()){
            String line = sc.nextLine();
            for(int i = 0; i < line.length(); i++){
                String activeChar = String.valueOf(line.charAt(i));
                retString.append(activeChar);               
            }
        }
        return retString;
    }

    //Decode method that traverses the Huffman tree recursively  to decode the encoded string
    //Base case is when string is empty or when a leaf node is reached
    //Recursively traverses left or right based on the bit in the encoded string
    public static StringBuilder decode(Node root, Node activeNode, StringBuilder encodedString, StringBuilder decoded){
        if (activeNode.key != null) {
            decoded.append(activeNode.key);
        if (encodedString.length() == 0) {
            return decoded;
        }
        return decode(root, root, encodedString, decoded);
        }
        if (encodedString.length() == 0) {
            return decoded;
        }
        char bit = encodedString.charAt(0);
        encodedString.deleteCharAt(0);
        if (bit == '0') {
            return decode(root, activeNode.left, encodedString, decoded);
        } else {
            return decode(root, activeNode.right, encodedString, decoded);
        }
    }

    //Create a map of characters to their binary codes
    public static Map<String, String> createBitMap(Node tree){
        Map<String,String> codes = new HashMap<String,String>();
        convertToBit(tree, codes, "");
        return codes;
    }

    //Encode the input file
    public static StringBuilder encode(String fileName, Node tree, Map<String, String> codes){
        codes = createBitMap(tree);
        StringBuilder encoded = new StringBuilder();
        Scanner sc;
        File input = new File(fileName);
        try{
            sc = new Scanner(input);
        } catch (FileNotFoundException e){
            e.printStackTrace();
            return null;
        }
        //System.out.println(codes);
        while(sc.hasNextLine()){
            String line = sc.nextLine();
            for(int i = 0; i < line.length(); i++){
                String activeChar = String.valueOf(line.charAt(i));
                encoded.append(codes.get(activeChar));               
            }
        }      
        return encoded;
    }

    public static void convertToBit(Node tree, Map<String,String> code, String c){
        if (tree.left == null && tree.right == null) {
			code.put(tree.key,c);
			return;
		}

		convertToBit(tree.left, code, c + '0');
		convertToBit(tree.right, code, c + '1');
	}

    public static Node createTree(String fileName){
        Scanner sc;
        File input = new File(fileName);
        try{
            sc = new Scanner(input);
        } catch (FileNotFoundException e){
            e.printStackTrace();
            return null;
        }
        HashMap<String, Integer> map = countFrequencies(sc);
        Heap<Node, Integer> h = mapToHeap(map);
        Node tree = heapToTree(h);
        sc.close();
        return tree;
    }

    public static void printHeap(Heap<String, Integer> h){
        String i = h.poll();
        if(i != null){
            System.out.println("Value: " + i);
            printHeap(h);
        }

    }
    
    public static HashMap<String, Integer> countFrequencies(Scanner input){
        HashMap<String, Integer> map = new HashMap<String, Integer>();
        while(input.hasNextLine()){
            String line = input.nextLine();
            for(int i = 0; i < line.length(); i++){
                String activeChar = String.valueOf(line.charAt(i));
                if(map.containsKey(activeChar)){                   
                    map.put(activeChar, map.get(activeChar)+1);
                } else {
                    map.put(activeChar, 1);
                }
                
            }
        }
        //System.out.println(map.values());     //debug helpers
        //System.out.println(map.keySet());

        return map;
    }

    public static Heap<Node, Integer> mapToHeap(HashMap<String, Integer> map){
       Heap<Node, Integer> h = new Heap<Node, Integer>();
        map.forEach( (k, v) -> {
            Node n = new Node(k, v);
            n.path = new StringBuilder();
            h.add(n, v);
        ;});
        return h;
    }

    public static Node heapToTree(Heap<Node, Integer> h){
        while(h.size() != 1){
            Node n = new Node(h.poll(), h.poll());

            h.add(n, n.freq);
        }
        return h.poll();
    }

    public static void printTree(Node root) {
    printSubtree(root, 0);
    }
    private static void printSubtree(Node n, int level) {
        if (n == null) {
        return;
        }
        printSubtree(n.right, level + 1);
        for (int i = 0; i < level; i++) {
        System.out.print("        ");
        }
        System.out.println(n.key + " " + n.freq + " " + n.path);
        printSubtree(n.left, level + 1);
    }
}
