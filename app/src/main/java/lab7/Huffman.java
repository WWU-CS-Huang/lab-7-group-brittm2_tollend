/*
 * This source file was generated by the Gradle 'init' task
 */
package lab7;
import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;
import heap.Heap;
import avl.AVL;
import java.util.HashMap; 
import java.util.ArrayList;
import java.util.Map;

public class Huffman {

    public static class Node{
        public String key;
        public Integer freq;
        public Node left;
        public Node right;
        public Node parent;
        public StringBuilder path;

        public Node(String s, Integer v){
            key = s;
            freq = v;
        }
        public Node(Node left, Node right){
            this.freq = left.freq + right.freq;
            this.left = left;
            this.right = right;
            this.left.parent = this;
            this.right.parent = this;
            this.path = new StringBuilder();
        }
    }

    public static void main(String[] args) {
        Node tree = createTree(args[0]);
        Map<String, String> bitMap = null;
        StringBuilder inputString = getInput(args[0]);
        StringBuilder encodedString = encode(args[0], tree, bitMap);
        StringBuilder decodedString = decode(tree, tree, new StringBuilder(encodedString), new StringBuilder());
        //printTree(tree);
        if(decodedString.length() < 100){
            System.out.println(inputString);
            System.out.println(encodedString);
            System.out.println(decodedString);
        }

    }
    
    public static StringBuilder getInput(String fileName){
        StringBuilder retString = new StringBuilder();
        Scanner sc;
        File input = new File(fileName);
        try{
            sc = new Scanner(input);
        } catch (FileNotFoundException e){
            e.printStackTrace();
            return null;
        }

        while(sc.hasNextLine()){
            String line = sc.nextLine();
            for(int i = 0; i < line.length(); i++){
                String activeChar = String.valueOf(line.charAt(i));
                retString.append(activeChar);               
            }
        }
        return retString;
    }

    public static StringBuilder decode(Node root, Node activeNode, StringBuilder encodedString, StringBuilder decoded){
        if(activeNode.key != null){
            decoded.append(activeNode.key);
            if(encodedString.length() == 0){
                return decoded;
            }else{
                decode(root, root, encodedString, decoded);

            }
        }else{
            if(encodedString.length() == 0){
                return decoded;
            }else if(encodedString.charAt(0) == '0'){
                encodedString = encodedString.deleteCharAt(0);
                decode(root, activeNode.left, encodedString, decoded);
            }else if(encodedString.charAt(0) == '1'){
                encodedString = encodedString.deleteCharAt(0);
                decode(root, activeNode.right, encodedString, decoded);
            }
        }
        return decoded;
    }

    public static Map<String, String> createBitMap(Node tree){
        Map<String,String> codes = new HashMap<String,String>();
        convertToBit(tree, codes, "");
        return codes;
    }

    public static StringBuilder encode(String fileName, Node tree, Map<String, String> codes){
        codes = createBitMap(tree);
        StringBuilder encoded = new StringBuilder();
        Scanner sc;
        File input = new File(fileName);
        try{
            sc = new Scanner(input);
        } catch (FileNotFoundException e){
            e.printStackTrace();
            return null;
        }
        convertToBit(tree, codes, "");
        //System.out.println(codes);
        while(sc.hasNextLine()){
            String line = sc.nextLine();
            for(int i = 0; i < line.length(); i++){
                String activeChar = String.valueOf(line.charAt(i));
                encoded.append(codes.get(activeChar));               
            }
        }
        
        return encoded;
    }

    public static void convertToBit(Node tree, Map<String,String> code, String c){
        if (tree.left == null && tree.right == null) {
			code.put(tree.key,c);
			return;
		}

		convertToBit(tree.left, code, c + '0');
		convertToBit(tree.right, code, c + '1');
	}

    public static Node createTree(String fileName){
        Scanner sc;
        File input = new File(fileName);
        try{
            sc = new Scanner(input);
        } catch (FileNotFoundException e){
            e.printStackTrace();
            return null;
        }
        HashMap<String, Integer> map = countFrequencies(sc);
        Heap<Node, Integer> h = mapToHeap(map);
        Node tree = heapToTree(h);
        sc.close();
        return tree;
    }

    public static void printHeap(Heap<String, Integer> h){
        String i = h.poll();
        if(i != null){
            System.out.println("Value: " + i);
            printHeap(h);
        }

    }
    
    public static HashMap<String, Integer> countFrequencies(Scanner input){
        HashMap<String, Integer> map = new HashMap<String, Integer>();
        while(input.hasNextLine()){
            String line = input.nextLine();
            for(int i = 0; i < line.length(); i++){
                String activeChar = String.valueOf(line.charAt(i));
                if(map.containsKey(activeChar)){                   
                    map.put(activeChar, map.get(activeChar)+1);
                } else {
                    map.put(activeChar, 1);
                }
                
            }
        }
        //System.out.println(map.values());     //debug helpers
        //System.out.println(map.keySet());

        return map;
    }

    public static Heap<Node, Integer> mapToHeap(HashMap<String, Integer> map){
       Heap<Node, Integer> h = new Heap<Node, Integer>();
        map.forEach( (k, v) -> {
            Node n = new Node(k, v);
            n.path = new StringBuilder();
            h.add(n, v);
        ;});
        return h;
    }

    public static Node heapToTree(Heap<Node, Integer> h){
        while(h.size() != 1){
            Node n = new Node(h.poll(), h.poll());

            h.add(n, n.freq);
        }
        return h.poll();
    }

    public static void printTree(Node root) {
    printSubtree(root, 0);
    }
    private static void printSubtree(Node n, int level) {
        if (n == null) {
        return;
        }
        printSubtree(n.right, level + 1);
        for (int i = 0; i < level; i++) {
        System.out.print("        ");
        }
        System.out.println(n.key + " " + n.freq + " " + n.path);
        printSubtree(n.left, level + 1);
    }
}
